//
// Copyright (C) [2020] Futurewei Technologies, Inc.
//
// FORCE-RISCV is licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR
// FIT FOR A PARTICULAR PURPOSE.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/*  !!! NOTICE !!!
    This file is automatically generated by the script: utils/enum_classes/create_enum_files.py
    Please do not modify this file manually.  Instead, modify the above mentioned script to re-generate this file.
*/

#include "EnumsRISCV.h"

#include <sstream>

#include "GenException.h"

using namespace std;

namespace Force {


  /*!
    Report an unknown enum value of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
  */
  static void unknown_enum_value(const string& enum_type_name, unsigned long long value)
  {
    stringstream err_stream;
    err_stream << "Unknown " << enum_type_name << " enum value: " << dec << value;
    throw EnumTypeError(err_stream.str());
  }

  /*!
    Report an unknown enum name of the type name given in enum_type_name parameter, by throwing an EnumTypeError exception.
  */
  static void unknown_enum_name(const string& enum_type_name, const string& enum_name)
  {
    stringstream err_stream;
    err_stream << "Unknown " << enum_type_name << " enum name: " << enum_name;
    throw EnumTypeError(err_stream.str());
  }

  /*!
    Throw an exception if in_str and enum_name are not identical.
  */
  static void validate(const string& specified_enum_name, const string& expected_enum_name, const string& enum_type_name)
  {
    if (specified_enum_name != expected_enum_name) {
      unknown_enum_name(enum_type_name, specified_enum_name);
    }
  }


  unsigned char ERegReserveGroupSize = 4;

  const string ERegReserveGroup_to_string(ERegReserveGroup in_enum)
  {
    switch (in_enum) {
    case ERegReserveGroup::GPR: return "GPR";
    case ERegReserveGroup::FPRSIMDR: return "FPRSIMDR";
    case ERegReserveGroup::VECREG: return "VECREG";
    case ERegReserveGroup::SystemRegister: return "SystemRegister";
    default:
      unknown_enum_value("ERegReserveGroup", (unsigned char)(in_enum));
    }
    return "";
  }

  ERegReserveGroup string_to_ERegReserveGroup(const string& in_str)
  {
    string enum_type_name = "ERegReserveGroup";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "FPRSIMDR", enum_type_name);
      return ERegReserveGroup::FPRSIMDR;
    case 71:
      validate(in_str, "GPR", enum_type_name);
      return ERegReserveGroup::GPR;
    case 83:
      validate(in_str, "SystemRegister", enum_type_name);
      return ERegReserveGroup::SystemRegister;
    case 86:
      validate(in_str, "VECREG", enum_type_name);
      return ERegReserveGroup::VECREG;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ERegReserveGroup::GPR;
  }

  ERegReserveGroup try_string_to_ERegReserveGroup(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "FPRSIMDR");
      return ERegReserveGroup::FPRSIMDR;
    case 71:
      okay = (in_str == "GPR");
      return ERegReserveGroup::GPR;
    case 83:
      okay = (in_str == "SystemRegister");
      return ERegReserveGroup::SystemRegister;
    case 86:
      okay = (in_str == "VECREG");
      return ERegReserveGroup::VECREG;
    default:
      okay = false;
      return ERegReserveGroup::GPR;
    }
    return ERegReserveGroup::GPR;
  }


  unsigned char EVmRegimeTypeSize = 4;

  const string EVmRegimeType_to_string(EVmRegimeType in_enum)
  {
    switch (in_enum) {
    case EVmRegimeType::M: return "M";
    case EVmRegimeType::S: return "S";
    case EVmRegimeType::HS: return "HS";
    case EVmRegimeType::VS: return "VS";
    default:
      unknown_enum_value("EVmRegimeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmRegimeType string_to_EVmRegimeType(const string& in_str)
  {
    string enum_type_name = "EVmRegimeType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      validate(in_str, "HS", enum_type_name);
      return EVmRegimeType::HS;
    case 77:
      validate(in_str, "M", enum_type_name);
      return EVmRegimeType::M;
    case 83:
      validate(in_str, "S", enum_type_name);
      return EVmRegimeType::S;
    case 86:
      validate(in_str, "VS", enum_type_name);
      return EVmRegimeType::VS;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmRegimeType::M;
  }

  EVmRegimeType try_string_to_EVmRegimeType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      okay = (in_str == "HS");
      return EVmRegimeType::HS;
    case 77:
      okay = (in_str == "M");
      return EVmRegimeType::M;
    case 83:
      okay = (in_str == "S");
      return EVmRegimeType::S;
    case 86:
      okay = (in_str == "VS");
      return EVmRegimeType::VS;
    default:
      okay = false;
      return EVmRegimeType::M;
    }
    return EVmRegimeType::M;
  }


  unsigned char EMemBankTypeSize = 1;

  const string EMemBankType_to_string(EMemBankType in_enum)
  {
    switch (in_enum) {
    case EMemBankType::Default: return "Default";
    default:
      unknown_enum_value("EMemBankType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemBankType string_to_EMemBankType(const string& in_str)
  {
    string enum_type_name = "EMemBankType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      validate(in_str, "Default", enum_type_name);
      return EMemBankType::Default;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemBankType::Default;
  }

  EMemBankType try_string_to_EMemBankType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 68:
      okay = (in_str == "Default");
      return EMemBankType::Default;
    default:
      okay = false;
      return EMemBankType::Default;
    }
    return EMemBankType::Default;
  }


  unsigned char EVmContextParamTypeSize = 10;

  const string EVmContextParamType_to_string(EVmContextParamType in_enum)
  {
    switch (in_enum) {
    case EVmContextParamType::MODE: return "MODE";
    case EVmContextParamType::MPRV: return "MPRV";
    case EVmContextParamType::MPP: return "MPP";
    case EVmContextParamType::SPP: return "SPP";
    case EVmContextParamType::MXR: return "MXR";
    case EVmContextParamType::SUM: return "SUM";
    case EVmContextParamType::MBE: return "MBE";
    case EVmContextParamType::SBE: return "SBE";
    case EVmContextParamType::UBE: return "UBE";
    case EVmContextParamType::TVM: return "TVM";
    default:
      unknown_enum_value("EVmContextParamType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmContextParamType string_to_EVmContextParamType(const string& in_str)
  {
    string enum_type_name = "EVmContextParamType";
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "MODE", enum_type_name);
      return EVmContextParamType::MODE;
    case 3:
      validate(in_str, "SPP", enum_type_name);
      return EVmContextParamType::SPP;
    case 4:
      validate(in_str, "MPRV", enum_type_name);
      return EVmContextParamType::MPRV;
    case 8:
      validate(in_str, "MBE", enum_type_name);
      return EVmContextParamType::MBE;
    case 16:
      validate(in_str, "UBE", enum_type_name);
      return EVmContextParamType::UBE;
    case 22:
      validate(in_str, "SBE", enum_type_name);
      return EVmContextParamType::SBE;
    case 25:
      validate(in_str, "TVM", enum_type_name);
      return EVmContextParamType::TVM;
    case 29:
      validate(in_str, "MPP", enum_type_name);
      return EVmContextParamType::MPP;
    case 30:
      validate(in_str, "SUM", enum_type_name);
      return EVmContextParamType::SUM;
    case 31:
      validate(in_str, "MXR", enum_type_name);
      return EVmContextParamType::MXR;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmContextParamType::MODE;
  }

  EVmContextParamType try_string_to_EVmContextParamType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "MODE");
      return EVmContextParamType::MODE;
    case 3:
      okay = (in_str == "SPP");
      return EVmContextParamType::SPP;
    case 4:
      okay = (in_str == "MPRV");
      return EVmContextParamType::MPRV;
    case 8:
      okay = (in_str == "MBE");
      return EVmContextParamType::MBE;
    case 16:
      okay = (in_str == "UBE");
      return EVmContextParamType::UBE;
    case 22:
      okay = (in_str == "SBE");
      return EVmContextParamType::SBE;
    case 25:
      okay = (in_str == "TVM");
      return EVmContextParamType::TVM;
    case 29:
      okay = (in_str == "MPP");
      return EVmContextParamType::MPP;
    case 30:
      okay = (in_str == "SUM");
      return EVmContextParamType::SUM;
    case 31:
      okay = (in_str == "MXR");
      return EVmContextParamType::MXR;
    default:
      okay = false;
      return EVmContextParamType::MODE;
    }
    return EVmContextParamType::MODE;
  }


  unsigned char EBranchConditionTypeSize = 8;

  const string EBranchConditionType_to_string(EBranchConditionType in_enum)
  {
    switch (in_enum) {
    case EBranchConditionType::BEQ: return "BEQ";
    case EBranchConditionType::BNE: return "BNE";
    case EBranchConditionType::BLT: return "BLT";
    case EBranchConditionType::BLTU: return "BLTU";
    case EBranchConditionType::BGE: return "BGE";
    case EBranchConditionType::BGEU: return "BGEU";
    case EBranchConditionType::CBEQZ: return "CBEQZ";
    case EBranchConditionType::CBNEZ: return "CBNEZ";
    default:
      unknown_enum_value("EBranchConditionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EBranchConditionType string_to_EBranchConditionType(const string& in_str)
  {
    string enum_type_name = "EBranchConditionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 64:
      validate(in_str, "BGE", enum_type_name);
      return EBranchConditionType::BGE;
    case 69:
      validate(in_str, "BGEU", enum_type_name);
      return EBranchConditionType::BGEU;
    case 73:
      validate(in_str, "BNE", enum_type_name);
      return EBranchConditionType::BNE;
    case 84:
      validate(in_str, "BLTU", enum_type_name);
      return EBranchConditionType::BLTU;
    case 86:
      validate(in_str, "BEQ", enum_type_name);
      return EBranchConditionType::BEQ;
    case 87:
      validate(in_str, "CBNEZ", enum_type_name);
      return EBranchConditionType::CBNEZ;
    case 90:
      validate(in_str, "BLT", enum_type_name);
      return EBranchConditionType::BLT;
    case 92:
      validate(in_str, "CBEQZ", enum_type_name);
      return EBranchConditionType::CBEQZ;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EBranchConditionType::BEQ;
  }

  EBranchConditionType try_string_to_EBranchConditionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(2 < size ? 2 : 2 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 64:
      okay = (in_str == "BGE");
      return EBranchConditionType::BGE;
    case 69:
      okay = (in_str == "BGEU");
      return EBranchConditionType::BGEU;
    case 73:
      okay = (in_str == "BNE");
      return EBranchConditionType::BNE;
    case 84:
      okay = (in_str == "BLTU");
      return EBranchConditionType::BLTU;
    case 86:
      okay = (in_str == "BEQ");
      return EBranchConditionType::BEQ;
    case 87:
      okay = (in_str == "CBNEZ");
      return EBranchConditionType::CBNEZ;
    case 90:
      okay = (in_str == "BLT");
      return EBranchConditionType::BLT;
    case 92:
      okay = (in_str == "CBEQZ");
      return EBranchConditionType::CBEQZ;
    default:
      okay = false;
      return EBranchConditionType::BEQ;
    }
    return EBranchConditionType::BEQ;
  }


  unsigned char EPteAttributeTypeSize = 11;

  const string EPteAttributeType_to_string(EPteAttributeType in_enum)
  {
    switch (in_enum) {
    case EPteAttributeType::Address: return "Address";
    case EPteAttributeType::IGNORED: return "IGNORED";
    case EPteAttributeType::RES0: return "RES0";
    case EPteAttributeType::SystemPage: return "SystemPage";
    case EPteAttributeType::RSW: return "RSW";
    case EPteAttributeType::DA: return "DA";
    case EPteAttributeType::G: return "G";
    case EPteAttributeType::U: return "U";
    case EPteAttributeType::X: return "X";
    case EPteAttributeType::WR: return "WR";
    case EPteAttributeType::V: return "V";
    default:
      unknown_enum_value("EPteAttributeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPteAttributeType string_to_EPteAttributeType(const string& in_str)
  {
    string enum_type_name = "EPteAttributeType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(9 < size ? 9 : 9 % size);

    switch (hash_value) {
    case 64:
      validate(in_str, "IGNORED", enum_type_name);
      return EPteAttributeType::IGNORED;
    case 65:
      validate(in_str, "Address", enum_type_name);
      return EPteAttributeType::Address;
    case 68:
      validate(in_str, "DA", enum_type_name);
      return EPteAttributeType::DA;
    case 71:
      validate(in_str, "G", enum_type_name);
      return EPteAttributeType::G;
    case 79:
      validate(in_str, "SystemPage", enum_type_name);
      return EPteAttributeType::SystemPage;
    case 82:
      validate(in_str, "RES0", enum_type_name);
      return EPteAttributeType::RES0;
    case 83:
      validate(in_str, "RSW", enum_type_name);
      return EPteAttributeType::RSW;
    case 85:
      validate(in_str, "U", enum_type_name);
      return EPteAttributeType::U;
    case 86:
      validate(in_str, "V", enum_type_name);
      return EPteAttributeType::V;
    case 87:
      validate(in_str, "WR", enum_type_name);
      return EPteAttributeType::WR;
    case 88:
      validate(in_str, "X", enum_type_name);
      return EPteAttributeType::X;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPteAttributeType::Address;
  }

  EPteAttributeType try_string_to_EPteAttributeType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(1 < size ? 1 : 1 % size) ^ in_str.at(9 < size ? 9 : 9 % size);

    switch (hash_value) {
    case 64:
      okay = (in_str == "IGNORED");
      return EPteAttributeType::IGNORED;
    case 65:
      okay = (in_str == "Address");
      return EPteAttributeType::Address;
    case 68:
      okay = (in_str == "DA");
      return EPteAttributeType::DA;
    case 71:
      okay = (in_str == "G");
      return EPteAttributeType::G;
    case 79:
      okay = (in_str == "SystemPage");
      return EPteAttributeType::SystemPage;
    case 82:
      okay = (in_str == "RES0");
      return EPteAttributeType::RES0;
    case 83:
      okay = (in_str == "RSW");
      return EPteAttributeType::RSW;
    case 85:
      okay = (in_str == "U");
      return EPteAttributeType::U;
    case 86:
      okay = (in_str == "V");
      return EPteAttributeType::V;
    case 87:
      okay = (in_str == "WR");
      return EPteAttributeType::WR;
    case 88:
      okay = (in_str == "X");
      return EPteAttributeType::X;
    default:
      okay = false;
      return EPteAttributeType::Address;
    }
    return EPteAttributeType::Address;
  }


  unsigned char EPageGranuleTypeSize = 1;

  const string EPageGranuleType_to_string(EPageGranuleType in_enum)
  {
    switch (in_enum) {
    case EPageGranuleType::G4K: return "G4K";
    default:
      unknown_enum_value("EPageGranuleType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPageGranuleType string_to_EPageGranuleType(const string& in_str)
  {
    string enum_type_name = "EPageGranuleType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 71:
      validate(in_str, "G4K", enum_type_name);
      return EPageGranuleType::G4K;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPageGranuleType::G4K;
  }

  EPageGranuleType try_string_to_EPageGranuleType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 71:
      okay = (in_str == "G4K");
      return EPageGranuleType::G4K;
    default:
      okay = false;
      return EPageGranuleType::G4K;
    }
    return EPageGranuleType::G4K;
  }


  unsigned char EPagingModeSize = 4;

  const string EPagingMode_to_string(EPagingMode in_enum)
  {
    switch (in_enum) {
    case EPagingMode::Bare: return "Bare";
    case EPagingMode::Sv32: return "Sv32";
    case EPagingMode::Sv39: return "Sv39";
    case EPagingMode::Sv48: return "Sv48";
    case EPagingMode::Sv32x4: return "Sv32x4";
    case EPagingMode::Sv39x4: return "Sv39x4";
    case EPagingMode::Sv48x4: return "Sv48x4";
    default:
      unknown_enum_value("EPagingMode", (unsigned char)(in_enum));
    }
    return "";
  }

  EPagingMode string_to_EPagingMode(const string& in_str)
  {
    string enum_type_name = "EPagingMode";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 50:
      if (size > 4) {
        validate(in_str, "Sv32x4", enum_type_name);
        return EPagingMode::Sv32x4;
      } else {
        validate(in_str, "Sv32", enum_type_name);
        return EPagingMode::Sv32; 
      }
    case 56:
      if (size > 4) {
        validate(in_str, "Sv48x4", enum_type_name);
        return EPagingMode::Sv48x4;
      } else {
        validate(in_str, "Sv48", enum_type_name);
        return EPagingMode::Sv48; 
      }
    case 57:
      if (size > 4) {
        validate(in_str, "Sv39x4", enum_type_name);
        return EPagingMode::Sv39x4;
      } else {
        validate(in_str, "Sv39", enum_type_name);
        return EPagingMode::Sv39; 
      }
    case 101:
      validate(in_str, "Bare", enum_type_name);
      return EPagingMode::Bare;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPagingMode::Bare;
  }

  EPagingMode try_string_to_EPagingMode(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size);

    switch (hash_value) {
    case 50:
      if (size > 4) {
        okay = (in_str == "Sv32x4");
        return EPagingMode::Sv32x4;
      } else {
        okay = (in_str == "Sv32");
        return EPagingMode::Sv32;
      }
    case 56:
      if (size > 4) {
        okay = (in_str == "Sv48x4");
        return EPagingMode::Sv48x4;
      } else {
        okay = (in_str == "Sv48");
        return EPagingMode::Sv48;
      }
    case 57:
      if (size > 4) {
        okay = (in_str == "Sv39x4");
        return EPagingMode::Sv39x4;
      } else {
        okay = (in_str == "Sv39");
        return EPagingMode::Sv39;
      }
    case 101:
      okay = (in_str == "Bare");
      return EPagingMode::Bare;
    default:
      okay = false;
      return EPagingMode::Bare;
    }
    return EPagingMode::Bare;
  }


  unsigned char EPageGenBoolAttrTypeSize = 12;

  const string EPageGenBoolAttrType_to_string(EPageGenBoolAttrType in_enum)
  {
    switch (in_enum) {
    case EPageGenBoolAttrType::FlatMap: return "FlatMap";
    case EPageGenBoolAttrType::InstrAddr: return "InstrAddr";
    case EPageGenBoolAttrType::Regulated: return "Regulated";
    case EPageGenBoolAttrType::ViaException: return "ViaException";
    case EPageGenBoolAttrType::Privileged: return "Privileged";
    case EPageGenBoolAttrType::Atomic: return "Atomic";
    case EPageGenBoolAttrType::CanAlias: return "CanAlias";
    case EPageGenBoolAttrType::ForceAlias: return "ForceAlias";
    case EPageGenBoolAttrType::ForceMemAttrs: return "ForceMemAttrs";
    case EPageGenBoolAttrType::ForceNewAddr: return "ForceNewAddr";
    case EPageGenBoolAttrType::NoDataPageFault: return "NoDataPageFault";
    case EPageGenBoolAttrType::NoInstrPageFault: return "NoInstrPageFault";
    default:
      unknown_enum_value("EPageGenBoolAttrType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPageGenBoolAttrType string_to_EPageGenBoolAttrType(const string& in_str)
  {
    string enum_type_name = "EPageGenBoolAttrType";
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      validate(in_str, "FlatMap", enum_type_name);
      return EPageGenBoolAttrType::FlatMap;
    case 80:
      validate(in_str, "NoInstrPageFault", enum_type_name);
      return EPageGenBoolAttrType::NoInstrPageFault;
    case 97:
      validate(in_str, "NoDataPageFault", enum_type_name);
      return EPageGenBoolAttrType::NoDataPageFault;
    case 100:
      validate(in_str, "InstrAddr", enum_type_name);
      return EPageGenBoolAttrType::InstrAddr;
    case 101:
      validate(in_str, "Regulated", enum_type_name);
      return EPageGenBoolAttrType::Regulated;
    case 103:
      validate(in_str, "Privileged", enum_type_name);
      return EPageGenBoolAttrType::Privileged;
    case 105:
      validate(in_str, "ForceAlias", enum_type_name);
      return EPageGenBoolAttrType::ForceAlias;
    case 109:
      validate(in_str, "ForceMemAttrs", enum_type_name);
      return EPageGenBoolAttrType::ForceMemAttrs;
    case 112:
      validate(in_str, "ViaException", enum_type_name);
      return EPageGenBoolAttrType::ViaException;
    case 115:
      validate(in_str, "CanAlias", enum_type_name);
      return EPageGenBoolAttrType::CanAlias;
    case 116:
      validate(in_str, "Atomic", enum_type_name);
      return EPageGenBoolAttrType::Atomic;
    case 119:
      validate(in_str, "ForceNewAddr", enum_type_name);
      return EPageGenBoolAttrType::ForceNewAddr;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPageGenBoolAttrType::FlatMap;
  }

  EPageGenBoolAttrType try_string_to_EPageGenBoolAttrType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      okay = (in_str == "FlatMap");
      return EPageGenBoolAttrType::FlatMap;
    case 80:
      okay = (in_str == "NoInstrPageFault");
      return EPageGenBoolAttrType::NoInstrPageFault;
    case 97:
      okay = (in_str == "NoDataPageFault");
      return EPageGenBoolAttrType::NoDataPageFault;
    case 100:
      okay = (in_str == "InstrAddr");
      return EPageGenBoolAttrType::InstrAddr;
    case 101:
      okay = (in_str == "Regulated");
      return EPageGenBoolAttrType::Regulated;
    case 103:
      okay = (in_str == "Privileged");
      return EPageGenBoolAttrType::Privileged;
    case 105:
      okay = (in_str == "ForceAlias");
      return EPageGenBoolAttrType::ForceAlias;
    case 109:
      okay = (in_str == "ForceMemAttrs");
      return EPageGenBoolAttrType::ForceMemAttrs;
    case 112:
      okay = (in_str == "ViaException");
      return EPageGenBoolAttrType::ViaException;
    case 115:
      okay = (in_str == "CanAlias");
      return EPageGenBoolAttrType::CanAlias;
    case 116:
      okay = (in_str == "Atomic");
      return EPageGenBoolAttrType::Atomic;
    case 119:
      okay = (in_str == "ForceNewAddr");
      return EPageGenBoolAttrType::ForceNewAddr;
    default:
      okay = false;
      return EPageGenBoolAttrType::FlatMap;
    }
    return EPageGenBoolAttrType::FlatMap;
  }


  unsigned char EPagingExceptionTypeSize = 6;

  const string EPagingExceptionType_to_string(EPagingExceptionType in_enum)
  {
    switch (in_enum) {
    case EPagingExceptionType::InstructionAccessFault: return "InstructionAccessFault";
    case EPagingExceptionType::LoadAccessFault: return "LoadAccessFault";
    case EPagingExceptionType::StoreAmoAccessFault: return "StoreAmoAccessFault";
    case EPagingExceptionType::InstructionPageFault: return "InstructionPageFault";
    case EPagingExceptionType::LoadPageFault: return "LoadPageFault";
    case EPagingExceptionType::StoreAmoPageFault: return "StoreAmoPageFault";
    default:
      unknown_enum_value("EPagingExceptionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPagingExceptionType string_to_EPagingExceptionType(const string& in_str)
  {
    string enum_type_name = "EPagingExceptionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(12 < size ? 12 : 12 % size);

    switch (hash_value) {
    case 70:
      validate(in_str, "StoreAmoPageFault", enum_type_name);
      return EPagingExceptionType::StoreAmoPageFault;
    case 97:
      validate(in_str, "InstructionPageFault", enum_type_name);
      return EPagingExceptionType::InstructionPageFault;
    case 99:
      validate(in_str, "InstructionAccessFault", enum_type_name);
      return EPagingExceptionType::InstructionAccessFault;
    case 115:
      validate(in_str, "StoreAmoAccessFault", enum_type_name);
      return EPagingExceptionType::StoreAmoAccessFault;
    case 116:
      validate(in_str, "LoadPageFault", enum_type_name);
      return EPagingExceptionType::LoadPageFault;
    case 117:
      validate(in_str, "LoadAccessFault", enum_type_name);
      return EPagingExceptionType::LoadAccessFault;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPagingExceptionType::InstructionAccessFault;
  }

  EPagingExceptionType try_string_to_EPagingExceptionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(12 < size ? 12 : 12 % size);

    switch (hash_value) {
    case 70:
      okay = (in_str == "StoreAmoPageFault");
      return EPagingExceptionType::StoreAmoPageFault;
    case 97:
      okay = (in_str == "InstructionPageFault");
      return EPagingExceptionType::InstructionPageFault;
    case 99:
      okay = (in_str == "InstructionAccessFault");
      return EPagingExceptionType::InstructionAccessFault;
    case 115:
      okay = (in_str == "StoreAmoAccessFault");
      return EPagingExceptionType::StoreAmoAccessFault;
    case 116:
      okay = (in_str == "LoadPageFault");
      return EPagingExceptionType::LoadPageFault;
    case 117:
      okay = (in_str == "LoadAccessFault");
      return EPagingExceptionType::LoadAccessFault;
    default:
      okay = false;
      return EPagingExceptionType::InstructionAccessFault;
    }
    return EPagingExceptionType::InstructionAccessFault;
  }


  unsigned char EVmConstraintTypeSize = 15;

  const string EVmConstraintType_to_string(EVmConstraintType in_enum)
  {
    switch (in_enum) {
    case EVmConstraintType::Existing: return "Existing";
    case EVmConstraintType::AddressError: return "AddressError";
    case EVmConstraintType::ReadOnly: return "ReadOnly";
    case EVmConstraintType::NoExecute: return "NoExecute";
    case EVmConstraintType::PrivilegedNoExecute: return "PrivilegedNoExecute";
    case EVmConstraintType::UnprivilegedNoExecute: return "UnprivilegedNoExecute";
    case EVmConstraintType::NoUserAccess: return "NoUserAccess";
    case EVmConstraintType::PageTable: return "PageTable";
    case EVmConstraintType::UserAccess: return "UserAccess";
    case EVmConstraintType::PageFault: return "PageFault";
    case EVmConstraintType::FlatMap: return "FlatMap";
    case EVmConstraintType::AccessFault: return "AccessFault";
    case EVmConstraintType::NoDataAccess: return "NoDataAccess";
    case EVmConstraintType::NotAccessed: return "NotAccessed";
    case EVmConstraintType::NotDirty: return "NotDirty";
    default:
      unknown_enum_value("EVmConstraintType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmConstraintType string_to_EVmConstraintType(const string& in_str)
  {
    string enum_type_name = "EVmConstraintType";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(6 < size ? 6 : 6 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "AddressError", enum_type_name);
      return EVmConstraintType::AddressError;
    case 4:
      validate(in_str, "FlatMap", enum_type_name);
      return EVmConstraintType::FlatMap;
    case 7:
      validate(in_str, "PageTable", enum_type_name);
      return EVmConstraintType::PageTable;
    case 8:
      validate(in_str, "ReadOnly", enum_type_name);
      return EVmConstraintType::ReadOnly;
    case 13:
      validate(in_str, "NoExecute", enum_type_name);
      return EVmConstraintType::NoExecute;
    case 16:
      validate(in_str, "PageFault", enum_type_name);
      return EVmConstraintType::PageFault;
    case 17:
      validate(in_str, "UserAccess", enum_type_name);
      return EVmConstraintType::UserAccess;
    case 19:
      validate(in_str, "PrivilegedNoExecute", enum_type_name);
      return EVmConstraintType::PrivilegedNoExecute;
    case 27:
      validate(in_str, "UnprivilegedNoExecute", enum_type_name);
      return EVmConstraintType::UnprivilegedNoExecute;
    case 29:
      validate(in_str, "Existing", enum_type_name);
      return EVmConstraintType::Existing;
    case 32:
      validate(in_str, "NoDataAccess", enum_type_name);
      return EVmConstraintType::NoDataAccess;
    case 35:
      validate(in_str, "AccessFault", enum_type_name);
      return EVmConstraintType::AccessFault;
    case 36:
      validate(in_str, "NotAccessed", enum_type_name);
      return EVmConstraintType::NotAccessed;
    case 48:
      validate(in_str, "NotDirty", enum_type_name);
      return EVmConstraintType::NotDirty;
    case 50:
      validate(in_str, "NoUserAccess", enum_type_name);
      return EVmConstraintType::NoUserAccess;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmConstraintType::Existing;
  }

  EVmConstraintType try_string_to_EVmConstraintType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(6 < size ? 6 : 6 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "AddressError");
      return EVmConstraintType::AddressError;
    case 4:
      okay = (in_str == "FlatMap");
      return EVmConstraintType::FlatMap;
    case 7:
      okay = (in_str == "PageTable");
      return EVmConstraintType::PageTable;
    case 8:
      okay = (in_str == "ReadOnly");
      return EVmConstraintType::ReadOnly;
    case 13:
      okay = (in_str == "NoExecute");
      return EVmConstraintType::NoExecute;
    case 16:
      okay = (in_str == "PageFault");
      return EVmConstraintType::PageFault;
    case 17:
      okay = (in_str == "UserAccess");
      return EVmConstraintType::UserAccess;
    case 19:
      okay = (in_str == "PrivilegedNoExecute");
      return EVmConstraintType::PrivilegedNoExecute;
    case 27:
      okay = (in_str == "UnprivilegedNoExecute");
      return EVmConstraintType::UnprivilegedNoExecute;
    case 29:
      okay = (in_str == "Existing");
      return EVmConstraintType::Existing;
    case 32:
      okay = (in_str == "NoDataAccess");
      return EVmConstraintType::NoDataAccess;
    case 35:
      okay = (in_str == "AccessFault");
      return EVmConstraintType::AccessFault;
    case 36:
      okay = (in_str == "NotAccessed");
      return EVmConstraintType::NotAccessed;
    case 48:
      okay = (in_str == "NotDirty");
      return EVmConstraintType::NotDirty;
    case 50:
      okay = (in_str == "NoUserAccess");
      return EVmConstraintType::NoUserAccess;
    default:
      okay = false;
      return EVmConstraintType::Existing;
    }
    return EVmConstraintType::Existing;
  }


  unsigned char EPrivilegeLevelTypeSize = 4;

  const string EPrivilegeLevelType_to_string(EPrivilegeLevelType in_enum)
  {
    switch (in_enum) {
    case EPrivilegeLevelType::U: return "U";
    case EPrivilegeLevelType::S: return "S";
    case EPrivilegeLevelType::H: return "H";
    case EPrivilegeLevelType::M: return "M";
    default:
      unknown_enum_value("EPrivilegeLevelType", (unsigned char)(in_enum));
    }
    return "";
  }

  EPrivilegeLevelType string_to_EPrivilegeLevelType(const string& in_str)
  {
    string enum_type_name = "EPrivilegeLevelType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      validate(in_str, "H", enum_type_name);
      return EPrivilegeLevelType::H;
    case 77:
      validate(in_str, "M", enum_type_name);
      return EPrivilegeLevelType::M;
    case 83:
      validate(in_str, "S", enum_type_name);
      return EPrivilegeLevelType::S;
    case 85:
      validate(in_str, "U", enum_type_name);
      return EPrivilegeLevelType::U;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EPrivilegeLevelType::U;
  }

  EPrivilegeLevelType try_string_to_EPrivilegeLevelType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 72:
      okay = (in_str == "H");
      return EPrivilegeLevelType::H;
    case 77:
      okay = (in_str == "M");
      return EPrivilegeLevelType::M;
    case 83:
      okay = (in_str == "S");
      return EPrivilegeLevelType::S;
    case 85:
      okay = (in_str == "U");
      return EPrivilegeLevelType::U;
    default:
      okay = false;
      return EPrivilegeLevelType::U;
    }
    return EPrivilegeLevelType::U;
  }


  unsigned char EMemAttributeImplTypeSize = 1;

  const string EMemAttributeImplType_to_string(EMemAttributeImplType in_enum)
  {
    switch (in_enum) {
    case EMemAttributeImplType::Unpredictable: return "Unpredictable";
    default:
      unknown_enum_value("EMemAttributeImplType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemAttributeImplType string_to_EMemAttributeImplType(const string& in_str)
  {
    string enum_type_name = "EMemAttributeImplType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 85:
      validate(in_str, "Unpredictable", enum_type_name);
      return EMemAttributeImplType::Unpredictable;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemAttributeImplType::Unpredictable;
  }

  EMemAttributeImplType try_string_to_EMemAttributeImplType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 85:
      okay = (in_str == "Unpredictable");
      return EMemAttributeImplType::Unpredictable;
    default:
      okay = false;
      return EMemAttributeImplType::Unpredictable;
    }
    return EMemAttributeImplType::Unpredictable;
  }


  unsigned char ESystemOptionTypeSize = 7;

  const string ESystemOptionType_to_string(ESystemOptionType in_enum)
  {
    switch (in_enum) {
    case ESystemOptionType::PrivilegeLevel: return "PrivilegeLevel";
    case ESystemOptionType::DisablePaging: return "DisablePaging";
    case ESystemOptionType::NoHandler: return "NoHandler";
    case ESystemOptionType::NoSkip: return "NoSkip";
    case ESystemOptionType::FlatMap: return "FlatMap";
    case ESystemOptionType::MatchedHandler: return "MatchedHandler";
    case ESystemOptionType::SkipBootCode: return "SkipBootCode";
    default:
      unknown_enum_value("ESystemOptionType", (unsigned char)(in_enum));
    }
    return "";
  }

  ESystemOptionType string_to_ESystemOptionType(const string& in_str)
  {
    string enum_type_name = "ESystemOptionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      validate(in_str, "FlatMap", enum_type_name);
      return ESystemOptionType::FlatMap;
    case 72:
      validate(in_str, "MatchedHandler", enum_type_name);
      return ESystemOptionType::MatchedHandler;
    case 80:
      validate(in_str, "DisablePaging", enum_type_name);
      return ESystemOptionType::DisablePaging;
    case 101:
      validate(in_str, "NoHandler", enum_type_name);
      return ESystemOptionType::NoHandler;
    case 103:
      validate(in_str, "PrivilegeLevel", enum_type_name);
      return ESystemOptionType::PrivilegeLevel;
    case 111:
      validate(in_str, "NoSkip", enum_type_name);
      return ESystemOptionType::NoSkip;
    case 116:
      validate(in_str, "SkipBootCode", enum_type_name);
      return ESystemOptionType::SkipBootCode;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESystemOptionType::PrivilegeLevel;
  }

  ESystemOptionType try_string_to_ESystemOptionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 70:
      okay = (in_str == "FlatMap");
      return ESystemOptionType::FlatMap;
    case 72:
      okay = (in_str == "MatchedHandler");
      return ESystemOptionType::MatchedHandler;
    case 80:
      okay = (in_str == "DisablePaging");
      return ESystemOptionType::DisablePaging;
    case 101:
      okay = (in_str == "NoHandler");
      return ESystemOptionType::NoHandler;
    case 103:
      okay = (in_str == "PrivilegeLevel");
      return ESystemOptionType::PrivilegeLevel;
    case 111:
      okay = (in_str == "NoSkip");
      return ESystemOptionType::NoSkip;
    case 116:
      okay = (in_str == "SkipBootCode");
      return ESystemOptionType::SkipBootCode;
    default:
      okay = false;
      return ESystemOptionType::PrivilegeLevel;
    }
    return ESystemOptionType::PrivilegeLevel;
  }


  unsigned char EExceptionClassTypeSize = 14;

  const string EExceptionClassType_to_string(EExceptionClassType in_enum)
  {
    switch (in_enum) {
    case EExceptionClassType::InstrAddrMisaligned: return "InstrAddrMisaligned";
    case EExceptionClassType::InstrAccessFault: return "InstrAccessFault";
    case EExceptionClassType::IllegalInstr: return "IllegalInstr";
    case EExceptionClassType::Breakpoint: return "Breakpoint";
    case EExceptionClassType::LoadAddrMisaligned: return "LoadAddrMisaligned";
    case EExceptionClassType::LoadAccessFault: return "LoadAccessFault";
    case EExceptionClassType::StoreAmoAddrMisaligned: return "StoreAmoAddrMisaligned";
    case EExceptionClassType::StoreAmoAccessFault: return "StoreAmoAccessFault";
    case EExceptionClassType::EnvCallFromUMode: return "EnvCallFromUMode";
    case EExceptionClassType::EnvCallFromSMode: return "EnvCallFromSMode";
    case EExceptionClassType::EnvCallFromMMode: return "EnvCallFromMMode";
    case EExceptionClassType::InstrPageFault: return "InstrPageFault";
    case EExceptionClassType::LoadPageFault: return "LoadPageFault";
    case EExceptionClassType::StoreAmoPageFault: return "StoreAmoPageFault";
    default:
      unknown_enum_value("EExceptionClassType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExceptionClassType string_to_EExceptionClassType(const string& in_str)
  {
    string enum_type_name = "EExceptionClassType";
    size_t size = in_str.size();
    char hash_value = in_str.at(11 < size ? 11 : 11 % size) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "InstrPageFault", enum_type_name);
      return EExceptionClassType::InstrPageFault;
    case 4:
      validate(in_str, "StoreAmoPageFault", enum_type_name);
      return EExceptionClassType::StoreAmoPageFault;
    case 8:
      validate(in_str, "LoadAddrMisaligned", enum_type_name);
      return EExceptionClassType::LoadAddrMisaligned;
    case 13:
      validate(in_str, "LoadAccessFault", enum_type_name);
      return EExceptionClassType::LoadAccessFault;
    case 19:
      validate(in_str, "Breakpoint", enum_type_name);
      return EExceptionClassType::Breakpoint;
    case 22:
      validate(in_str, "StoreAmoAccessFault", enum_type_name);
      return EExceptionClassType::StoreAmoAccessFault;
    case 27:
      validate(in_str, "StoreAmoAddrMisaligned", enum_type_name);
      return EExceptionClassType::StoreAmoAddrMisaligned;
    case 30:
      validate(in_str, "IllegalInstr", enum_type_name);
      return EExceptionClassType::IllegalInstr;
    case 31:
      validate(in_str, "InstrAddrMisaligned", enum_type_name);
      return EExceptionClassType::InstrAddrMisaligned;
    case 32:
      validate(in_str, "LoadPageFault", enum_type_name);
      return EExceptionClassType::LoadPageFault;
    case 34:
      validate(in_str, "EnvCallFromMMode", enum_type_name);
      return EExceptionClassType::EnvCallFromMMode;
    case 51:
      validate(in_str, "InstrAccessFault", enum_type_name);
      return EExceptionClassType::InstrAccessFault;
    case 58:
      validate(in_str, "EnvCallFromUMode", enum_type_name);
      return EExceptionClassType::EnvCallFromUMode;
    case 60:
      validate(in_str, "EnvCallFromSMode", enum_type_name);
      return EExceptionClassType::EnvCallFromSMode;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExceptionClassType::InstrAddrMisaligned;
  }

  EExceptionClassType try_string_to_EExceptionClassType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(11 < size ? 11 : 11 % size) ^ in_str.at(13 < size ? 13 : 13 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "InstrPageFault");
      return EExceptionClassType::InstrPageFault;
    case 4:
      okay = (in_str == "StoreAmoPageFault");
      return EExceptionClassType::StoreAmoPageFault;
    case 8:
      okay = (in_str == "LoadAddrMisaligned");
      return EExceptionClassType::LoadAddrMisaligned;
    case 13:
      okay = (in_str == "LoadAccessFault");
      return EExceptionClassType::LoadAccessFault;
    case 19:
      okay = (in_str == "Breakpoint");
      return EExceptionClassType::Breakpoint;
    case 22:
      okay = (in_str == "StoreAmoAccessFault");
      return EExceptionClassType::StoreAmoAccessFault;
    case 27:
      okay = (in_str == "StoreAmoAddrMisaligned");
      return EExceptionClassType::StoreAmoAddrMisaligned;
    case 30:
      okay = (in_str == "IllegalInstr");
      return EExceptionClassType::IllegalInstr;
    case 31:
      okay = (in_str == "InstrAddrMisaligned");
      return EExceptionClassType::InstrAddrMisaligned;
    case 32:
      okay = (in_str == "LoadPageFault");
      return EExceptionClassType::LoadPageFault;
    case 34:
      okay = (in_str == "EnvCallFromMMode");
      return EExceptionClassType::EnvCallFromMMode;
    case 51:
      okay = (in_str == "InstrAccessFault");
      return EExceptionClassType::InstrAccessFault;
    case 58:
      okay = (in_str == "EnvCallFromUMode");
      return EExceptionClassType::EnvCallFromUMode;
    case 60:
      okay = (in_str == "EnvCallFromSMode");
      return EExceptionClassType::EnvCallFromSMode;
    default:
      okay = false;
      return EExceptionClassType::InstrAddrMisaligned;
    }
    return EExceptionClassType::InstrAddrMisaligned;
  }


  unsigned char EInstructionGroupTypeSize = 4;

  const string EInstructionGroupType_to_string(EInstructionGroupType in_enum)
  {
    switch (in_enum) {
    case EInstructionGroupType::General: return "General";
    case EInstructionGroupType::Float: return "Float";
    case EInstructionGroupType::System: return "System";
    case EInstructionGroupType::Vector: return "Vector";
    default:
      unknown_enum_value("EInstructionGroupType", (unsigned char)(in_enum));
    }
    return "";
  }

  EInstructionGroupType string_to_EInstructionGroupType(const string& in_str)
  {
    string enum_type_name = "EInstructionGroupType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "Float", enum_type_name);
      return EInstructionGroupType::Float;
    case 71:
      validate(in_str, "General", enum_type_name);
      return EInstructionGroupType::General;
    case 83:
      validate(in_str, "System", enum_type_name);
      return EInstructionGroupType::System;
    case 86:
      validate(in_str, "Vector", enum_type_name);
      return EInstructionGroupType::Vector;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EInstructionGroupType::General;
  }

  EInstructionGroupType try_string_to_EInstructionGroupType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "Float");
      return EInstructionGroupType::Float;
    case 71:
      okay = (in_str == "General");
      return EInstructionGroupType::General;
    case 83:
      okay = (in_str == "System");
      return EInstructionGroupType::System;
    case 86:
      okay = (in_str == "Vector");
      return EInstructionGroupType::Vector;
    default:
      okay = false;
      return EInstructionGroupType::General;
    }
    return EInstructionGroupType::General;
  }


  unsigned char EInstructionExtensionTypeSize = 21;

  const string EInstructionExtensionType_to_string(EInstructionExtensionType in_enum)
  {
    switch (in_enum) {
    case EInstructionExtensionType::Default: return "Default";
    case EInstructionExtensionType::RV32I: return "RV32I";
    case EInstructionExtensionType::RV64I: return "RV64I";
    case EInstructionExtensionType::RV32A: return "RV32A";
    case EInstructionExtensionType::RV64A: return "RV64A";
    case EInstructionExtensionType::RV32M: return "RV32M";
    case EInstructionExtensionType::RV64M: return "RV64M";
    case EInstructionExtensionType::RV32F: return "RV32F";
    case EInstructionExtensionType::RV64F: return "RV64F";
    case EInstructionExtensionType::RV32D: return "RV32D";
    case EInstructionExtensionType::RV64D: return "RV64D";
    case EInstructionExtensionType::RV32Q: return "RV32Q";
    case EInstructionExtensionType::RV64Q: return "RV64Q";
    case EInstructionExtensionType::Zicsr: return "Zicsr";
    case EInstructionExtensionType::Zifencei: return "Zifencei";
    case EInstructionExtensionType::RV32C: return "RV32C";
    case EInstructionExtensionType::RV64C: return "RV64C";
    case EInstructionExtensionType::RV128C: return "RV128C";
    case EInstructionExtensionType::RV64Priv: return "RV64Priv";
    case EInstructionExtensionType::RV32H: return "RV32H";
    case EInstructionExtensionType::RV64H: return "RV64H";
    default:
      unknown_enum_value("EInstructionExtensionType", (unsigned char)(in_enum));
    }
    return "";
  }

  EInstructionExtensionType string_to_EInstructionExtensionType(const string& in_str)
  {
    string enum_type_name = "EInstructionExtensionType";
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 1:
      validate(in_str, "Zicsr", enum_type_name);
      return EInstructionExtensionType::Zicsr;
    case 10:
      validate(in_str, "RV128C", enum_type_name);
      return EInstructionExtensionType::RV128C;
    case 11:
      validate(in_str, "Zifencei", enum_type_name);
      return EInstructionExtensionType::Zifencei;
    case 20:
      validate(in_str, "Default", enum_type_name);
      return EInstructionExtensionType::Default;
    case 99:
      validate(in_str, "RV32Q", enum_type_name);
      return EInstructionExtensionType::RV32Q;
    case 100:
      validate(in_str, "RV64Priv", enum_type_name);
      return EInstructionExtensionType::RV64Priv;
    case 101:
      validate(in_str, "RV64Q", enum_type_name);
      return EInstructionExtensionType::RV64Q;
    case 112:
      validate(in_str, "RV64D", enum_type_name);
      return EInstructionExtensionType::RV64D;
    case 113:
      validate(in_str, "RV32C", enum_type_name);
      return EInstructionExtensionType::RV32C;
    case 114:
      validate(in_str, "RV64F", enum_type_name);
      return EInstructionExtensionType::RV64F;
    case 115:
      validate(in_str, "RV32A", enum_type_name);
      return EInstructionExtensionType::RV32A;
    case 116:
      validate(in_str, "RV32F", enum_type_name);
      return EInstructionExtensionType::RV32F;
    case 117:
      validate(in_str, "RV64A", enum_type_name);
      return EInstructionExtensionType::RV64A;
    case 118:
      validate(in_str, "RV32D", enum_type_name);
      return EInstructionExtensionType::RV32D;
    case 119:
      validate(in_str, "RV64C", enum_type_name);
      return EInstructionExtensionType::RV64C;
    case 121:
      validate(in_str, "RV64M", enum_type_name);
      return EInstructionExtensionType::RV64M;
    case 122:
      validate(in_str, "RV32H", enum_type_name);
      return EInstructionExtensionType::RV32H;
    case 123:
      validate(in_str, "RV32I", enum_type_name);
      return EInstructionExtensionType::RV32I;
    case 124:
      validate(in_str, "RV64H", enum_type_name);
      return EInstructionExtensionType::RV64H;
    case 125:
      validate(in_str, "RV64I", enum_type_name);
      return EInstructionExtensionType::RV64I;
    case 127:
      validate(in_str, "RV32M", enum_type_name);
      return EInstructionExtensionType::RV32M;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EInstructionExtensionType::Default;
  }

  EInstructionExtensionType try_string_to_EInstructionExtensionType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(3 < size ? 3 : 3 % size) ^ in_str.at(4 < size ? 4 : 4 % size);

    switch (hash_value) {
    case 1:
      okay = (in_str == "Zicsr");
      return EInstructionExtensionType::Zicsr;
    case 10:
      okay = (in_str == "RV128C");
      return EInstructionExtensionType::RV128C;
    case 11:
      okay = (in_str == "Zifencei");
      return EInstructionExtensionType::Zifencei;
    case 20:
      okay = (in_str == "Default");
      return EInstructionExtensionType::Default;
    case 99:
      okay = (in_str == "RV32Q");
      return EInstructionExtensionType::RV32Q;
    case 100:
      okay = (in_str == "RV64Priv");
      return EInstructionExtensionType::RV64Priv;
    case 101:
      okay = (in_str == "RV64Q");
      return EInstructionExtensionType::RV64Q;
    case 112:
      okay = (in_str == "RV64D");
      return EInstructionExtensionType::RV64D;
    case 113:
      okay = (in_str == "RV32C");
      return EInstructionExtensionType::RV32C;
    case 114:
      okay = (in_str == "RV64F");
      return EInstructionExtensionType::RV64F;
    case 115:
      okay = (in_str == "RV32A");
      return EInstructionExtensionType::RV32A;
    case 116:
      okay = (in_str == "RV32F");
      return EInstructionExtensionType::RV32F;
    case 117:
      okay = (in_str == "RV64A");
      return EInstructionExtensionType::RV64A;
    case 118:
      okay = (in_str == "RV32D");
      return EInstructionExtensionType::RV32D;
    case 119:
      okay = (in_str == "RV64C");
      return EInstructionExtensionType::RV64C;
    case 121:
      okay = (in_str == "RV64M");
      return EInstructionExtensionType::RV64M;
    case 122:
      okay = (in_str == "RV32H");
      return EInstructionExtensionType::RV32H;
    case 123:
      okay = (in_str == "RV32I");
      return EInstructionExtensionType::RV32I;
    case 124:
      okay = (in_str == "RV64H");
      return EInstructionExtensionType::RV64H;
    case 125:
      okay = (in_str == "RV64I");
      return EInstructionExtensionType::RV64I;
    case 127:
      okay = (in_str == "RV32M");
      return EInstructionExtensionType::RV32M;
    default:
      okay = false;
      return EInstructionExtensionType::Default;
    }
    return EInstructionExtensionType::Default;
  }


  unsigned char EMemOrderingTypeSize = 6;

  const string EMemOrderingType_to_string(EMemOrderingType in_enum)
  {
    switch (in_enum) {
    case EMemOrderingType::Init: return "Init";
    case EMemOrderingType::Atomic: return "Atomic";
    case EMemOrderingType::AtomicRW: return "AtomicRW";
    case EMemOrderingType::Ordered: return "Ordered";
    case EMemOrderingType::LimitedOrdered: return "LimitedOrdered";
    case EMemOrderingType::OrderedRW: return "OrderedRW";
    default:
      unknown_enum_value("EMemOrderingType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemOrderingType string_to_EMemOrderingType(const string& in_str)
  {
    string enum_type_name = "EMemOrderingType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 0:
      validate(in_str, "Ordered", enum_type_name);
      return EMemOrderingType::Ordered;
    case 3:
      validate(in_str, "LimitedOrdered", enum_type_name);
      return EMemOrderingType::LimitedOrdered;
    case 22:
      validate(in_str, "AtomicRW", enum_type_name);
      return EMemOrderingType::AtomicRW;
    case 29:
      validate(in_str, "OrderedRW", enum_type_name);
      return EMemOrderingType::OrderedRW;
    case 53:
      validate(in_str, "Atomic", enum_type_name);
      return EMemOrderingType::Atomic;
    case 61:
      validate(in_str, "Init", enum_type_name);
      return EMemOrderingType::Init;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemOrderingType::Init;
  }

  EMemOrderingType try_string_to_EMemOrderingType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 0:
      okay = (in_str == "Ordered");
      return EMemOrderingType::Ordered;
    case 3:
      okay = (in_str == "LimitedOrdered");
      return EMemOrderingType::LimitedOrdered;
    case 22:
      okay = (in_str == "AtomicRW");
      return EMemOrderingType::AtomicRW;
    case 29:
      okay = (in_str == "OrderedRW");
      return EMemOrderingType::OrderedRW;
    case 53:
      okay = (in_str == "Atomic");
      return EMemOrderingType::Atomic;
    case 61:
      okay = (in_str == "Init");
      return EMemOrderingType::Init;
    default:
      okay = false;
      return EMemOrderingType::Init;
    }
    return EMemOrderingType::Init;
  }


  unsigned char EExceptionVectorTypeSize = 2;

  const string EExceptionVectorType_to_string(EExceptionVectorType in_enum)
  {
    switch (in_enum) {
    case EExceptionVectorType::DefaultMachineModeVector: return "DefaultMachineModeVector";
    case EExceptionVectorType::DefaultSupervisorModeVector: return "DefaultSupervisorModeVector";
    default:
      unknown_enum_value("EExceptionVectorType", (unsigned char)(in_enum));
    }
    return "";
  }

  EExceptionVectorType string_to_EExceptionVectorType(const string& in_str)
  {
    string enum_type_name = "EExceptionVectorType";
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 77:
      validate(in_str, "DefaultMachineModeVector", enum_type_name);
      return EExceptionVectorType::DefaultMachineModeVector;
    case 83:
      validate(in_str, "DefaultSupervisorModeVector", enum_type_name);
      return EExceptionVectorType::DefaultSupervisorModeVector;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EExceptionVectorType::DefaultMachineModeVector;
  }

  EExceptionVectorType try_string_to_EExceptionVectorType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(7 < size ? 7 : 7 % size);

    switch (hash_value) {
    case 77:
      okay = (in_str == "DefaultMachineModeVector");
      return EExceptionVectorType::DefaultMachineModeVector;
    case 83:
      okay = (in_str == "DefaultSupervisorModeVector");
      return EExceptionVectorType::DefaultSupervisorModeVector;
    default:
      okay = false;
      return EExceptionVectorType::DefaultMachineModeVector;
    }
    return EExceptionVectorType::DefaultMachineModeVector;
  }


  unsigned char ESystemOpTypeSize = 1;

  const string ESystemOpType_to_string(ESystemOpType in_enum)
  {
    switch (in_enum) {
    case ESystemOpType::None: return "None";
    default:
      unknown_enum_value("ESystemOpType", (unsigned char)(in_enum));
    }
    return "";
  }

  ESystemOpType string_to_ESystemOpType(const string& in_str)
  {
    string enum_type_name = "ESystemOpType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 78:
      validate(in_str, "None", enum_type_name);
      return ESystemOpType::None;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return ESystemOpType::None;
  }

  ESystemOpType try_string_to_ESystemOpType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 78:
      okay = (in_str == "None");
      return ESystemOpType::None;
    default:
      okay = false;
      return ESystemOpType::None;
    }
    return ESystemOpType::None;
  }


  unsigned char EMemoryAttributeTypeSize = 27;

  const string EMemoryAttributeType_to_string(EMemoryAttributeType in_enum)
  {
    switch (in_enum) {
    case EMemoryAttributeType::MainRegion: return "MainRegion";
    case EMemoryAttributeType::IORegion: return "IORegion";
    case EMemoryAttributeType::EmptyRegion: return "EmptyRegion";
    case EMemoryAttributeType::LRSC: return "LRSC";
    case EMemoryAttributeType::AMONone: return "AMONone";
    case EMemoryAttributeType::AMOSwap: return "AMOSwap";
    case EMemoryAttributeType::AMOLogical: return "AMOLogical";
    case EMemoryAttributeType::AMOArithmetic: return "AMOArithmetic";
    case EMemoryAttributeType::AMOAligned: return "AMOAligned";
    case EMemoryAttributeType::AMOMisaligned: return "AMOMisaligned";
    case EMemoryAttributeType::RVWMO: return "RVWMO";
    case EMemoryAttributeType::RVTSO: return "RVTSO";
    case EMemoryAttributeType::RelaxedOrdering: return "RelaxedOrdering";
    case EMemoryAttributeType::StrongOrderingChannel0: return "StrongOrderingChannel0";
    case EMemoryAttributeType::StrongOrderingChannel1: return "StrongOrderingChannel1";
    case EMemoryAttributeType::CoherentL1: return "CoherentL1";
    case EMemoryAttributeType::CoherentL2: return "CoherentL2";
    case EMemoryAttributeType::CoherentL3: return "CoherentL3";
    case EMemoryAttributeType::Incoherent: return "Incoherent";
    case EMemoryAttributeType::CacheableMasterPrivate: return "CacheableMasterPrivate";
    case EMemoryAttributeType::CacheableShared: return "CacheableShared";
    case EMemoryAttributeType::CacheableSlavePrivate: return "CacheableSlavePrivate";
    case EMemoryAttributeType::Uncacheable: return "Uncacheable";
    case EMemoryAttributeType::ReadIdempotent: return "ReadIdempotent";
    case EMemoryAttributeType::ReadNonIdempotent: return "ReadNonIdempotent";
    case EMemoryAttributeType::WriteIdempotent: return "WriteIdempotent";
    case EMemoryAttributeType::WriteNonIdempotent: return "WriteNonIdempotent";
    default:
      unknown_enum_value("EMemoryAttributeType", (unsigned char)(in_enum));
    }
    return "";
  }

  EMemoryAttributeType string_to_EMemoryAttributeType(const string& in_str)
  {
    string enum_type_name = "EMemoryAttributeType";
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(19 < size ? 19 : 19 % size) ^ in_str.at(21 < size ? 21 : 21 % size);

    switch (hash_value) {
    case 6:
      validate(in_str, "StrongOrderingChannel0", enum_type_name);
      return EMemoryAttributeType::StrongOrderingChannel0;
    case 7:
      validate(in_str, "StrongOrderingChannel1", enum_type_name);
      return EMemoryAttributeType::StrongOrderingChannel1;
    case 29:
      validate(in_str, "CoherentL1", enum_type_name);
      return EMemoryAttributeType::CoherentL1;
    case 30:
      validate(in_str, "CoherentL2", enum_type_name);
      return EMemoryAttributeType::CoherentL2;
    case 31:
      validate(in_str, "CoherentL3", enum_type_name);
      return EMemoryAttributeType::CoherentL3;
    case 66:
      {
        char hash_value_66 = in_str.at(0);

        switch (hash_value_66) {
        case 69:
          validate(in_str, "EmptyRegion", enum_type_name);
          return EMemoryAttributeType::EmptyRegion;
        case 77:
          validate(in_str, "MainRegion", enum_type_name);
          return EMemoryAttributeType::MainRegion;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 68:
      validate(in_str, "CacheableShared", enum_type_name);
      return EMemoryAttributeType::CacheableShared;
    case 69:
      validate(in_str, "IORegion", enum_type_name);
      return EMemoryAttributeType::IORegion;
    case 71:
      validate(in_str, "CacheableMasterPrivate", enum_type_name);
      return EMemoryAttributeType::CacheableMasterPrivate;
    case 73:
      validate(in_str, "AMOMisaligned", enum_type_name);
      return EMemoryAttributeType::AMOMisaligned;
    case 75:
      {
        size_t size_75 = in_str.size();
        char hash_value_75 = in_str.at(2 < size_75 ? 2 : 2 % size_75);

        switch (hash_value_75) {
        case 84:
          validate(in_str, "RVTSO", enum_type_name);
          return EMemoryAttributeType::RVTSO;
        case 87:
          validate(in_str, "RVWMO", enum_type_name);
          return EMemoryAttributeType::RVWMO;
        default:
          unknown_enum_name(enum_type_name, in_str);
        }
      }
    case 78:
      validate(in_str, "RelaxedOrdering", enum_type_name);
      return EMemoryAttributeType::RelaxedOrdering;
    case 81:
      validate(in_str, "WriteNonIdempotent", enum_type_name);
      return EMemoryAttributeType::WriteNonIdempotent;
    case 82:
      validate(in_str, "Uncacheable", enum_type_name);
      return EMemoryAttributeType::Uncacheable;
    case 83:
      validate(in_str, "Incoherent", enum_type_name);
      return EMemoryAttributeType::Incoherent;
    case 86:
      validate(in_str, "WriteIdempotent", enum_type_name);
      return EMemoryAttributeType::WriteIdempotent;
    case 88:
      validate(in_str, "AMOArithmetic", enum_type_name);
      return EMemoryAttributeType::AMOArithmetic;
    case 91:
      validate(in_str, "ReadIdempotent", enum_type_name);
      return EMemoryAttributeType::ReadIdempotent;
    case 93:
      validate(in_str, "LRSC", enum_type_name);
      return EMemoryAttributeType::LRSC;
    case 96:
      validate(in_str, "AMOLogical", enum_type_name);
      return EMemoryAttributeType::AMOLogical;
    case 97:
      validate(in_str, "AMOSwap", enum_type_name);
      return EMemoryAttributeType::AMOSwap;
    case 104:
      validate(in_str, "AMOAligned", enum_type_name);
      return EMemoryAttributeType::AMOAligned;
    case 110:
      validate(in_str, "AMONone", enum_type_name);
      return EMemoryAttributeType::AMONone;
    case 116:
      validate(in_str, "CacheableSlavePrivate", enum_type_name);
      return EMemoryAttributeType::CacheableSlavePrivate;
    case 125:
      validate(in_str, "ReadNonIdempotent", enum_type_name);
      return EMemoryAttributeType::ReadNonIdempotent;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EMemoryAttributeType::MainRegion;
  }

  EMemoryAttributeType try_string_to_EMemoryAttributeType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(0) ^ in_str.at(19 < size ? 19 : 19 % size) ^ in_str.at(21 < size ? 21 : 21 % size);

    switch (hash_value) {
    case 6:
      okay = (in_str == "StrongOrderingChannel0");
      return EMemoryAttributeType::StrongOrderingChannel0;
    case 7:
      okay = (in_str == "StrongOrderingChannel1");
      return EMemoryAttributeType::StrongOrderingChannel1;
    case 29:
      okay = (in_str == "CoherentL1");
      return EMemoryAttributeType::CoherentL1;
    case 30:
      okay = (in_str == "CoherentL2");
      return EMemoryAttributeType::CoherentL2;
    case 31:
      okay = (in_str == "CoherentL3");
      return EMemoryAttributeType::CoherentL3;
    case 66:
      {
        char hash_value_66 = in_str.at(0);

        switch (hash_value_66) {
        case 69:
          okay = (in_str == "EmptyRegion");
          return EMemoryAttributeType::EmptyRegion;
        case 77:
          okay = (in_str == "MainRegion");
          return EMemoryAttributeType::MainRegion;
        default:
          okay = false;
          return EMemoryAttributeType::MainRegion;
        }
      }
    case 68:
      okay = (in_str == "CacheableShared");
      return EMemoryAttributeType::CacheableShared;
    case 69:
      okay = (in_str == "IORegion");
      return EMemoryAttributeType::IORegion;
    case 71:
      okay = (in_str == "CacheableMasterPrivate");
      return EMemoryAttributeType::CacheableMasterPrivate;
    case 73:
      okay = (in_str == "AMOMisaligned");
      return EMemoryAttributeType::AMOMisaligned;
    case 75:
      {
        size_t size_75 = in_str.size();
        char hash_value_75 = in_str.at(2 < size_75 ? 2 : 2 % size_75);

        switch (hash_value_75) {
        case 84:
          okay = (in_str == "RVTSO");
          return EMemoryAttributeType::RVTSO;
        case 87:
          okay = (in_str == "RVWMO");
          return EMemoryAttributeType::RVWMO;
        default:
          okay = false;
          return EMemoryAttributeType::MainRegion;
        }
      }
    case 78:
      okay = (in_str == "RelaxedOrdering");
      return EMemoryAttributeType::RelaxedOrdering;
    case 81:
      okay = (in_str == "WriteNonIdempotent");
      return EMemoryAttributeType::WriteNonIdempotent;
    case 82:
      okay = (in_str == "Uncacheable");
      return EMemoryAttributeType::Uncacheable;
    case 83:
      okay = (in_str == "Incoherent");
      return EMemoryAttributeType::Incoherent;
    case 86:
      okay = (in_str == "WriteIdempotent");
      return EMemoryAttributeType::WriteIdempotent;
    case 88:
      okay = (in_str == "AMOArithmetic");
      return EMemoryAttributeType::AMOArithmetic;
    case 91:
      okay = (in_str == "ReadIdempotent");
      return EMemoryAttributeType::ReadIdempotent;
    case 93:
      okay = (in_str == "LRSC");
      return EMemoryAttributeType::LRSC;
    case 96:
      okay = (in_str == "AMOLogical");
      return EMemoryAttributeType::AMOLogical;
    case 97:
      okay = (in_str == "AMOSwap");
      return EMemoryAttributeType::AMOSwap;
    case 104:
      okay = (in_str == "AMOAligned");
      return EMemoryAttributeType::AMOAligned;
    case 110:
      okay = (in_str == "AMONone");
      return EMemoryAttributeType::AMONone;
    case 116:
      okay = (in_str == "CacheableSlavePrivate");
      return EMemoryAttributeType::CacheableSlavePrivate;
    case 125:
      okay = (in_str == "ReadNonIdempotent");
      return EMemoryAttributeType::ReadNonIdempotent;
    default:
      okay = false;
      return EMemoryAttributeType::MainRegion;
    }
    return EMemoryAttributeType::MainRegion;
  }


  unsigned char EVmInfoBoolTypeSize = 3;

  const string EVmInfoBoolType_to_string(EVmInfoBoolType in_enum)
  {
    switch (in_enum) {
    case EVmInfoBoolType::MODE: return "MODE";
    case EVmInfoBoolType::MPRV: return "MPRV";
    case EVmInfoBoolType::TVM: return "TVM";
    default:
      unknown_enum_value("EVmInfoBoolType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVmInfoBoolType string_to_EVmInfoBoolType(const string& in_str)
  {
    string enum_type_name = "EVmInfoBoolType";
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 79:
      validate(in_str, "MODE", enum_type_name);
      return EVmInfoBoolType::MODE;
    case 80:
      validate(in_str, "MPRV", enum_type_name);
      return EVmInfoBoolType::MPRV;
    case 86:
      validate(in_str, "TVM", enum_type_name);
      return EVmInfoBoolType::TVM;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVmInfoBoolType::MODE;
  }

  EVmInfoBoolType try_string_to_EVmInfoBoolType(const string& in_str, bool& okay)
  {
    okay = true;
    size_t size = in_str.size();
    char hash_value = in_str.at(1 < size ? 1 : 1 % size);

    switch (hash_value) {
    case 79:
      okay = (in_str == "MODE");
      return EVmInfoBoolType::MODE;
    case 80:
      okay = (in_str == "MPRV");
      return EVmInfoBoolType::MPRV;
    case 86:
      okay = (in_str == "TVM");
      return EVmInfoBoolType::TVM;
    default:
      okay = false;
      return EVmInfoBoolType::MODE;
    }
    return EVmInfoBoolType::MODE;
  }


  unsigned char EVectorLayoutTypeSize = 3;

  const string EVectorLayoutType_to_string(EVectorLayoutType in_enum)
  {
    switch (in_enum) {
    case EVectorLayoutType::Vtype: return "Vtype";
    case EVectorLayoutType::FixedElementSize: return "FixedElementSize";
    case EVectorLayoutType::WholeRegister: return "WholeRegister";
    default:
      unknown_enum_value("EVectorLayoutType", (unsigned char)(in_enum));
    }
    return "";
  }

  EVectorLayoutType string_to_EVectorLayoutType(const string& in_str)
  {
    string enum_type_name = "EVectorLayoutType";
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      validate(in_str, "FixedElementSize", enum_type_name);
      return EVectorLayoutType::FixedElementSize;
    case 86:
      validate(in_str, "Vtype", enum_type_name);
      return EVectorLayoutType::Vtype;
    case 87:
      validate(in_str, "WholeRegister", enum_type_name);
      return EVectorLayoutType::WholeRegister;
    default:
      unknown_enum_name(enum_type_name, in_str);
    }
    return EVectorLayoutType::Vtype;
  }

  EVectorLayoutType try_string_to_EVectorLayoutType(const string& in_str, bool& okay)
  {
    okay = true;
    char hash_value = in_str.at(0);

    switch (hash_value) {
    case 70:
      okay = (in_str == "FixedElementSize");
      return EVectorLayoutType::FixedElementSize;
    case 86:
      okay = (in_str == "Vtype");
      return EVectorLayoutType::Vtype;
    case 87:
      okay = (in_str == "WholeRegister");
      return EVectorLayoutType::WholeRegister;
    default:
      okay = false;
      return EVectorLayoutType::Vtype;
    }
    return EVectorLayoutType::Vtype;
  }

}
